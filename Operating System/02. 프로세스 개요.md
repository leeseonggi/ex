## 2강 프로세스 개요

### 1. 프로세스(Process)

실행중인 프로그램 - PID라는 코드로 분류가됨 왜?=> 같은 이름의 프로그램들이 동시에(z.B 크롬 창이 한 20개면 같은 크롬이니까) 실행될수도 있음

프로그램 - 정적, 수동적(동작을 하지않음 그냥 프로그램 그 상태)

프로세스 - 동적 , 능동적, 동작함

##### 운영체제로부터 자원을 할당받아서 동작함

=> 운영체제가 프로그램을 실행(프로세스)을 위해 CPU나 메모리, 입출력장치, 파일 등의 자원을 할당하면

=> 프로세스의 명령이 CPU의 도움을 받아 실행 됨 

##### 사용자가 만들어낸 프로세스와 시스템이 만들어낸 프로세스가 있음

=> 시스템이 동작하여 사용자가 컴퓨터를 사용하기 위한 기반 프로그램을 시스템이 동작시킴

=> 그러면 그 위에서 사용자가 사용하고자 하는 프로그램을 구동

=> 사용자모드일때는 일반 응용프로그램들 커널 모드일때는 운영체제에 손을 댐 시스템이 아니라 사용자가

#### 프로세스 관리자 역할 

프로세스 생성, 삭제

프로세스 실행(CPU할당) 을 위한 스케줄 결정

프로세스 상태 관리, 상태 전이를 처리

##### 프로세스의 상태(5 상태 모델)

생성 - 처음 작업이 시스템에 주어진 상태

준비 - 실행 준비가 되어 CPU할당을 기다리는 상태

실행 - 프로세스가 처리되는 상태

종료  - 모든 처리가 완료되어 사용자에 반황되는 상태

대기 - 프로세스가 특정 자원을 할당받을 때까지 또는 I/O 작업이 끝날 때까지 작업이 보류되는 상태

​			(준비 -> 실행 - 디스패치)

생성 -> 준비<-->실행->종료

​				(실행 -> 준비 - 할당시간 만료)

(재개조건 만족)<-대기<-(이벤트)

#### 프로세스 제어 블록(Process Control Block, PBC)

프로세스의 관리를 위한 목적

프로세스의 정보를 보관

각 프로세스마다 존재

프로세스가 진행함에 따라 내용이 변경됨

=>프로세스를 하나의 블록으로 만들어 관리와 제어를 용이하게 한것

| 프로세스 상태(실행중인지 아닌지 프로세스의 상태)             |
| ------------------------------------------------------------ |
| 프로세스 번호(PID) - 프로세스의 이름이 같을수도 있으니 지정해주는 고유번호(포인터 비슷) |
| 프로세스 카운터(PC) - 현재까지 어디까지 실행했는지 그리고 다음엔 어떤것을 처리할지 가리키는 값, CPU가 잠깐 쉬었다가 다시돌아 오더라도 바로 작업수행 가능 |
| 레지스터들 - 현재 CPU안에 레지스터 값들을 다 저장 해 놔야함 ->왜? => 잠깐 다른작업을 하고 돌아왔을때 그대로 되살려서 일을 진행해야하기 떄문에 제어블록 안에 저장해 놓음 |
| 메모리 관리 정보                                             |
| 프로세스 우선순위                                            |
| 회계정보                                                     |

=> 이런식으로 하나하나의 블록으로 됨

#### 프로세스 생성과 종료

프로세스 생성 작업 

=> 프로세스 이름(번호, PID) 결정

실행을 위한 준비 큐에 삽입

초기 우선순위 부여

프로세스 제어블록 PCB 생성

##### 프로세스 생성 방법 -> 시스템 호출(사용자 모드에서 운영체제에 접근하기 위해 필요한 그것)

하나의 프로세스가 프로세스 생성 시스템 호출을 통해 새로운 프로세스 생성

예 : fork() =>프로세스 생성 함수를 사용할 때에 순간적으로 시스템 호출이 되어 운영체제에서 운영체제에서 함수호출이 되고 다시 되돌아 온다

호출하는 프로세스 : 부모 프로세스

생성되는 프로세스 : 자식 프로세스

=> 사용자가 자식 프로세스를 생성하면 그 프로세스가 필요에 의해 또 자식 프로세스를 새끼침

=> 더더 위로 올라가면 컴퓨터 부팅시 시스템에서 자동적으로 실행시키는 시스템프로세스들이 있고 트리 구조로 하나하나씩 내려오게 됨

##### 생성되는 프로세스의 자원

운영체제로부터 직접 얻음

##### 부모프로세스로부터 자원 일부 얻음=> 자식 프로세스의 자원은 부모로부터만 얻게 제한됨

==> 왜? ==> 운영체제로부터 자원을 다 얻으면은 불필요한 자식 프로세스가 수백 수천개가 생길 수 있음

==> 그런 상황을 방지하기 위해 부모 프로세스에 할당된 부분만으로 자원일 받아 시스템의 과부하를 방지함

#### 프로세스 종료

가장 이상적인것 - 마지막 명령이 실행을 마치는 경우(사실상 정상종료)

프로그램 종료 시스템 호출(z.B : exit() )을 통하는 경우

=> 어쨌든 프로그램 종료 후 부모 프로그램에 실행결과를 돌려 줌(return)

##### 프로세스 종료 시스템 호출

부모에 의해서만 호출됨

자식프로세스가 할당된 자원 사용을 초과 또는 자식 프로세스가 필요치 않을때

#### 프로세스 간의 관계

|               | 독립적 프로세스                               | 유기적 프로세스                 |
| ------------- | --------------------------------------------- | ------------------------------- |
| 의미          | 다른 프로세스와 영향을 주고받지 않음          | 다른 프로세스와 영향을 주고받음 |
| 프로세스 상태 | 다른 프로세스와 공유 안함                     | 다른 프로세스와 공유            |
| 실행          | 결정적, 재생 가능                             | 비결정적, 재생 불가능           |
|               | 다른 프로세스와 무관 하게 중단 및 재시작 가능 |                                 |
| 데이터        | 다른 프로세스와 공유 안함                     | 다른 프로세스와 공유함          |



### 2. 쓰레드

#### 프로세스와 쓰레드

##### 전통적 프로세스

프로세스 - 처리의 기본단위, 자원 소유의 단위(하나의 주소공간, PID), 디스패칭의 단위(하나의 제어흐름(준비에서 실행단계 디스패치))

그러나 -> 단일 프로세스 내에서 동시처리가 불가능하다

=> 그리하여 유연하게 사용하기 위해 고안된것이 쓰레드(Thread)

##### 쓰레드(Thread)

프로세스의 다중처리를 위해서 고안됨 -> 하나의 프로세스에 다수의 쓰레드가 있을수 있고 항상 하나 이상의 쓰레드가 있음

디스패치의 단위가 프로세스에서 쓰레드가 됨

실행에 필요한 최소한의 단위만 가지고 프로세스의 실행 환경을 공유(프로세스에 속해있기 떄문에)

프로세스를 조각조각 내서 동시다발적 작업을 위해 고안된 구조

##### 다중 쓰레드의 장점

멀티 CPU나 멀티코어는 데이터 병렬 처리 가능

=> 만약 3개의 쓰레드가 프로세스 안에 있고 3개의 CPU가 처리할수 있다면 각각의 쓰레드를 각각의 코어 또는 CPU가 처리하고

=> 그 쓰레드를 처리 속도별로 분류해 놓은 경우 더 효율적으로 처리가 가능하게 됨

### 3. 스케줄링

작업들이 큐에 쌓임

==> 상위단계 스케줄링을 이용해서 작업들을 선정하여 우선순위 대로 프로세스를 생성하여 준비 큐에 쌓음(입출력(I/O) 중심 또는 연산중심 균형을 맞처 프로세스 생성)

=>aber 준비큐에 쌓인 프로세스들이 전단계로 갈 수는 없음

===> 그래서 중간단계 스케줄링을 거침

=> 왜?

====> CPU에서 할당할 자원이 부족하거나 너무 많은 프로세스들이 준비큐에 들어오게 된다든지 하는 상황이 오게되면은 중간당계 스케줄링을 이용하여 일시중지를 시킴(단기 부하 조절)

==> 이 일시 중지될 프로세스를 감별해내는게 중간단계 스케줄링 그리고 어떤 프로세스를 재 추입 시킬지 결정하는것도 중간단계 스케줄링

====> 이렇게 작업을 실행시키고 하는데 작업을 실행할 때에 CPU를 할당하여 우선순위에 따라서 프로세스에 배당하는것이 하위단계 스케줄링

===> 수행주체 : 디스패쳐(Dispatcher)

=> 여기서 다 끝나면 종료

#### 스케줄링 기본 목표

공정성 - 모든 프로세스가 일정 수준 이상의 CPU를 할당받아 작업을 받을수 있게 해야됨 

균형 -  시스템 자원들이 충분히 활용되게 해야됨

##### 스케줄링 정책

선점(Preemptive)

진행중인 프로세스를 제끼고 본인이 딱 그자리 선점하는거

인터럽트를 걸고 CPU를 강제 할당받는것

높은 우선순위 프로세스 긴급처리 -> 특히 실시간 운영체제에서 많이씀(순간순간 반응이 빨라야 하기 때문에)

대화식 시분할 시스템에서 빠른 응답을 유지하는데 유용

문맥 교환에 따른 오버헤드 발생(시간적인 손해 발생)

문맥 - CPU의 모든 레지스터와 기타 운영체제에 따라 요구되는 프로세스의 상태

문맥교환 - CPU의 현재 실행하고 있는 프로세스의 문맥을 PCB에 저장하고 다음 프로세스의 PCB로부터 문맥을 복원하는 작업(빼서 넣고 다시 빼고 넣고)

==> 순간적으로 레지스터를 다 저장하고 다른작업을 하고 다시 PC를 타고 들어가야하는데 그 과정에서 문맥교환을 하는데 너무 많은 레지스터들이 저장되는데 공간이 필요해 넘치는 경우가 있다

하지만 반응속도가 더 중요하기 때문에 사용

##### 비선점(Nonpreemptive)

순서대로 다 쓰면 쓰고싶은만큼 다 쓰면 된다

==> 대충 시간이 얼마나 걸릴지 알수 있고 응답시간 예측이 가능하다

====> 선점같은 일이 일어나지 않기 때문에

==> 짧은 프로세스가 긴 프로세스를 기다려야만 할수 있음(1초짜리가 1일짜리를 기다려야함)